---
layout:     post
title:      "基于程序控制流图的错误提示实现"
subtitle:   "好难，不会"
date:       2018-01-20
author:     "TautCony"
header-img: null
image:
  credit: GeoPattern
  creditlink: https://github.com/btmills/geopattern
tags:
    - 
---

毕设简单地说就是基于大量已经正确的代码，对提交的错误代码进行大概的错误位置提示。

<!--more-->

<!-- 2018-01-20 begin -->

最早是期望着基于诸如`SIM`的程序试求两个程序的diff，然而这一类程序仅基于文法，并不可行。

如果基于[`AST`](https://en.wikipedia.org/wiki/Abstract_syntax_tree)，而整个树的形态受代码的书写风格也会出现很大的变化，讨论下来并不可行。

讨论后决定从程序的[`CFG`](https://en.wikipedia.org/wiki/Control_flow_graph)出发，进行后续的处理。

当能够获得一个程序的`CFG`之后，首先很容易就会得出一个非常朴素的想法，只要知道如何在`CFG`层面上从左边图变到右边的图，那么很显然我们就能知道两个程序之间的对应关系，那么，两者之间的区别想必也能够拿到了。

但是很尴尬的一点，从一个图变到另一个图，其间的操作为图编辑距离（GED），最优解的算法复杂度是指数级的，这就很让人黯然心伤了。对于任意一个稍微大一点点的图，其求解时间就是不可接受的。

而在代码查重层面上并不需要两个图之间的对应情况，以[这篇文章](https://www.cs.utexas.edu/~bbeth/files/AComparisonOfSimilarityTechniquesForDetectingSourceCodePlagiarism.pdf)为例，他将程序`CFG`每个点的内容都舍弃掉，将两个邻接矩阵填充到一样的大小，一维化后再进行传统的编辑距离的计算，称能比较两个程序`CFG`形态上的相似程度（which我尚未理解其得出距离后如何定义其程度），并将其作为整个程序的相似性。但是无论如何，这样处理出来的数据，也没法做进一步的处理了。

可能会想，那么不需要最优解呢，差不多用用就成了。说是这么说，哪来的不是最优的`GED`的实现来给你用呢，毕竟直接称`GED`的话，只是一个定义而已。另外，本来这个图上的编辑距离的应用和研究少，相关的内容也比较难以找到。

从老师给了这个题目开始，一直是想东想西，毫无进展，我认为可能一个很根本的原因就是，现在一切都是在理论上想象的，这样使得实现的方向上只有一个非常宽松的限制，任意一个方向，都不能说它不行，也没法确信它是能够行的通的，也使得了我写了好多代码却都只能删除了事。

ぐるぐる回して，又打算准备着眼于基于[图的同构](https://en.wikipedia.org/wiki/Graph_isomorphism)的思路。考虑这样一个情况，当两个人思路相近的时候，那么其程序的整个流程总**应是**一样的，应该放弃什么某人多写了一堆导致两个图之间需要一定的插入删除才能对应上的高难度放卫星的思想。那么两个`CFG`的结构应该是相同的，仅会在序号的标号上存在出入。

以这个前提为基础，那么整个流程就变成了这样：

1. 获取程序的`CFG`。
1. 建立对应的图。
1. 在两个程序的`CFG`上进行同构的匹配，获得两者之间的对应关系。
1. 对于所有分支节点，再进行一个相互比较，从而修正分支的对应关系。
1. 再对于所有的对应节点，进行类似`SIM`的词法上的分析，进行求diff的操作。
1. 设计一个评级，将差异较大的节点位置输出。

而图的同构这一问题，虽然依旧是NP问题，研究的人就多了些了，也有了更多的一点底气。稍作搜索，可以找到一个称为VF2的图的同构的算法，似乎挺符合的。先找了一个基于原论文的java实现进行简单研读并上手试了一下。又是令人绝望的一天，其运行结果甚至传入两个相同的图都给我返回了`false`，不知是哪里出现了偏差。此时，又突然发现boost里竟然有实现这个算法，令人惊奇，应选黄道吉日阅读文档进行测试。

因为，我的程序，已经从`C#`->`Python`->`C#`->`java`走了三个语言了，很快就要写不动了。

<!-- 2018-01-20 end -->
